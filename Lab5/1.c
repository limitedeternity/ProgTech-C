#include <stdio.h>
#include <stdlib.h>

void getch()
{
#ifdef WIN32
  system("pause");
#else
  system("read -n1 -p '' key");
#endif
}

int main(int argc, char const *argv[])
{
  /* 
  Объявление переменной dec. Тип переменной - int. 
  Схема верна: число 10 записано в память, адресу присвоено короткое имя dec.
  Тип соответствует.
  */

  int dec = 10;
  printf("%d\n", dec);

  /* 
  Объявление переменной-указателя на адрес переменной dec. Тип - *int.
  Для получения значения указанной переменной нужно применить операцию разыменовывания.

  *ptr == dec

  Схема верна: указатель с именем ptr1 сцеплен с адресом в памяти, 
  где записано число 10, который имеет название dec.
  Тип соответствует.
  */

  int *ptr1 = &dec;
  printf("%d\n", *ptr1);

  /*
  Объявление переменной-указателя ptr2, копирующего свойства ptr1. Тип - *int.
  ptr2 начинает указывать в то же место в памяти, куда указывает ptr1.
  Схема верна.
  */

  int *ptr2 = ptr1;
  printf("%d\n", *ptr2);

  /*
  Объявление переменной-указателя, указывающего на адрес указателя, указывающего на адрес переменной dec. 
  Тип - **int.
  Это должно выглядеть так:
  int *ref1 = &dec;
  int **ref = &ref1;

  Но у нас - попытка объявить указатель на указатель без наличия первого указателя, 
  на который должен указывать второй.
  Компилятор бросит предупреждение о несовместимости типов, 
  потому что тип переменной ref в нашем случае - *int, а не **int.
  Схема верна для типа *int, но не для **int. Таким образом, схема неверна и не соответствует типу.
  */

  int **ref = &dec;
  printf("%d\n", **ref);

  getch();
  return 0;
}
